## Простые алгоритмы
### 1) Простой поиск

Перебор массива осуществляется до нахождения нужного элемента.  
Для 99 элемента из 100, потребуется 99 шагов;  
**Количество шагов**: n  
**Время выполнения**: линейное время O(n)  

### 2) Бинарный поиск

Каждый раз  выбирается элемент в середине диапазона и исключается половина элементов, которая не подходит.  
**Время выполнения**: логарифмическое время O(log n) //  по основанию 2   
[Код](https://repl.it/@NimfaMargo/binary-search)  
```
const binarySearch = (arr, item) => {
 let low = 0; // верхняя граница части списка
 let high = arr.length - 1; // нижняя граница

 while (low <= high) { // пока эта часть не сократиться до одного элемента
   const middle = Math.round((low + high) / 2);
   const guess = arr[middle];
   if (guess === item) {
     return middle;
   } else if (guess > item) {
     high = middle - 1;
   } else if (guess < item) {
     low = middle + 1;
   } else {
     return null;
   }
 }
}
binarySearch([1, 2, 3, 6, 8, -1], 2)
```   
## Время выполнения O-большое  
O-большое определяет время выполнения в худшем случае  
### Примеры О-большого  
- O(log n) бинарный поиск
- O(n) простой поиск
- O(n*log n) быстрая сортировка (быстро)
- О(n^2) сортировка выбором (медленно)
- О(n!) задача о коммивояжере (очень медленно)   

***Основное***:   
1. Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операций
2. Время выполнения алгоритмов выражается как О-большое
3. Бинарный поиск намного быстрее простого
4. Время выполнения O(log n) быстрее O(n) с увеличением размера списка оно становится намного быстрее
5. Константы в О-большом иногда могут иметь значение. По этой причине быстрая сортировка O(n log n) быстрее сортировки слиянием O(n log n).
6. При сравнении бинарной и простой сортировки константа не играет роли, потому что O(log n) сильно превосходит O(n).   

### Массивы и связанные списки
- Память компьютера - огромный шкаф с ящиками
- Чтобы сохранить набор элементов используются массивы и списки
- В массиве все элементы хранятся рядом друг с другом
- В списке элементы распределяются в произвольных местах памяти, при этом в одном элементе храниться адрес следующего.
- Массивы обеспечивают быстрое чтение
- Списки обеспечивают быструю вставку и удаление
- Все элементы массива должны быть однотипными  

![](/Users/margo/code/algorithms/images/table.png)
