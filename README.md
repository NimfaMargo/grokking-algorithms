[Простые алгоритмы](#простые-алгоритмы)   
[O-большое](#время-выполнения-o-большое)   
[Массивы и связанные списки](#массивы-и-связанные-списки)  
[Сортировка выбором](#сортировка-выбором)   
[Рекурсия и Стек](#рекурсия-и-стек)   
[Быстрая сортировка](#быстрая-сортировка)  
[Хеш-таблицы](#хеш-таблицы)   
[Поиск в ширину](#поиск-в-ширину)

## Простые алгоритмы
### 1) Простой поиск

Перебор массива осуществляется до нахождения нужного элемента.  
Для 99 элемента из 100, потребуется 99 шагов;  
**Количество шагов**: n  
**Время выполнения**: линейное время O(n)  

### 2) Бинарный поиск

Каждый раз  выбирается элемент в середине диапазона и исключается половина элементов, которая не подходит.  
**Время выполнения**: логарифмическое время O(log n) //  по основанию 2   
[Код](https://repl.it/@NimfaMargo/binary-search)  
```
const binarySearch = (arr, item) => {
 let low = 0; // верхняя граница части списка
 let high = arr.length - 1; // нижняя граница

 while (low <= high) { // пока эта часть не сократиться до одного элемента
   const middle = Math.round((low + high) / 2);
   const guess = arr[middle];
   if (guess === item) {
     return middle;
   } else if (guess > item) {
     high = middle - 1;
   } else if (guess < item) {
     low = middle + 1;
   } else {
     return null;
   }
 }
}
binarySearch([1, 2, 3, 6, 8, -1], 2)
```   
## Время выполнения, O-большое  
O-большое определяет время выполнения в худшем случае  
### Примеры О-большого  
- O(log n) бинарный поиск
- O(n) простой поиск
- O(n*log n) быстрая сортировка (быстро)
- О(n^2) сортировка выбором (медленно)
- О(n!) задача о коммивояжере (очень медленно)   

***Основное***:   
1. Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операций
2. Время выполнения алгоритмов выражается как О-большое
3. Бинарный поиск намного быстрее простого
4. Время выполнения O(log n) быстрее O(n) с увеличением размера списка оно становится намного быстрее
5. Константы в О-большом иногда могут иметь значение. По этой причине быстрая сортировка O(n log n) быстрее сортировки слиянием O(n log n).
6. При сравнении бинарной и простой сортировки константа не играет роли, потому что O(log n) сильно превосходит O(n).   

## Массивы и связанные списки
- Память компьютера - огромный шкаф с ящиками
- Чтобы сохранить набор элементов используются массивы и списки
- В массиве все элементы хранятся рядом друг с другом
- В списке элементы распределяются в произвольных местах памяти, при этом в одном элементе храниться адрес следующего.
- Массивы обеспечивают быстрое чтение
- Списки обеспечивают быструю вставку и удаление
- Все элементы массива должны быть однотипными  

![](/images/table.png)

## Сортировка выбором
Чтобы найти наименьший элемент в массиве, необходимо проверить каждый элемент  за O(n) -  и эту операцию нужно выполнить n раз. ***O(n * n) = O(n^2)***  
#### Алгоритм
1. Найти наименьший элемент в массиве.  
2. Повторить для всех элементов.   

[Код](https://repl.it/@NimfaMargo/selectionSort)
```
const findSmallest = (arr) => {
 let smallestIndex = 0;
 const smallestItem = arr[smallestIndex];
 for (let i = 1; i < arr.length; i++) {
   if (arr[i] < smallestItem) {
     smallestIndex = i
   }
 }
 return smallestIndex;
};

const selectionSort = (arr) => {
 const newArr = [];
 const range = arr.length
 for (let i = 0; i < range; i++) {
   const smallestIndex = findSmallest(arr);  // n - раз выполнить операцию c O(n)
   newArr.push(arr[smallestIndex]);
   arr.splice(smallestIndex, 1);
 }
 return newArr;
}
selectionSort([1, 3, 7, 2, -1])
```    

## Рекурсия и Стек
- Когда функция вызывает саму себя - это рекурсия.
- В каждой рекурсивной ф-ии должно быть два случая: базовый и рекурсивный
- Стек поддерживает две операци: занесение и извлечение элементов
- Все вызовы функций сохраняются в стеке вызовов
- Если стек вызовов станет очень большим, он займет слишком много памяти.

## Быстрая сортировка
Алгоритм быстрой сортировки уникален тем, что его скорость зависит от выбора опорного элемента.    
- В худшем случае  - O(n^2)  
- В среднем - O(n log n)  
#### В основе стратегия “Разделяй и властвуй”
1. Сначала определяем базовый случай -  простейший из всех возможных
2. Задача делится или сокращается до тех пор, пока не будет сведена к базовому случаю.
#### Алгоритм
1. Выбрать опорный элемент
Разделить массив на два подмассива: элементы, меньшие опорного и элементы большие опорного;
2. Рекурсивно применить быструю сортировку к двум подмассивам;

[Код](https://repl.it/@NimfaMargo/quickSort)

```
const quickSort = (arr) => {
 if (arr.length < 2) {
   return arr;
 }
 const pivot = arr[0];  // опорный элемент
 const less = arr.filter(el => el < pivot);
 const greater = arr.filter(el => el > pivot);
 return [...quickSort(less), pivot, ...quickSort(greater)]
}
quickSort([1, 3, 7, 2, -1, 10])

```
#### Худший и средний случай  
- На завершение каждого уровня сортировки требуется времени **O(n)**, так как выбирается опорный элемент, а потом перебираются все оставшиеся элементы.   
- Высота стека вызовов равна **O(log n)**, тк каждый уровень занимает **O(n)**:
- Весь алгоритм:  **O(n) * O(log n) = O(n log n)** -  лучший случай
- В худшем случае высота равна **O(n)** уровней : **O(n) * O(n) = O(n^2)**
- Если всегда выбирать опорным случайный элемент в массиве, быстрая сортировка в среднем завершится за время **O(n log n)**.


## Хеш-таблицы
### Хеш-функция
Представляет собой ф-ию, которая получает строку (данные) и возвращает число. (отображает строки на числа)
- Она должна быть последовательной. Один и тот же результат при тех же входных данных.
- Разным словам должны соответствовать разные числа
### Хеш-функция + массив = хеш-таблица
**По-другому - ассоциативный массив.**  
- В любом приличном языке есть реализация хеш-таблиц.  
- Хеш-таблица состоит из ключей и значений.  
### Использование
Хеши хорошо подходят для решения следующих задач:
1. Моделирование отношений между объектами
2. Устранение дубликатов
3. Кеширование/запоминание данных вместо выполнения работы на сервере
### Хорошая хеш-функция
- Должна обеспечивать равномерное распределение значений в массиве
- Не создавать скопление и не порождает коллизии

*Скопление* - это если несколько ключей отображаются на один элемент, в этом элементе создается связанный список, если список большой, скорость поиска будет O(n)    

![](/images/table2.png)

## Поиск в ширину
### Алгоритм
1. Смоделировать задачу в виде графа
2. Решить задачу методом поиска в ширину    
[Код](https://repl.it/@NimfaMargo/breadth-first-search)
```
const graph = { // ассоциативный массив
 'you': ['alice', 'bob', 'claire'] ,
 'bob': ['anji', 'peggy'],
 'alice': ['peggy'],
 'claire': ['jon'],
 'anji': [],
 'peggy': [],
 'jon': [],
};
const personIsJon = (name) => name === 'jon'

const searchName = (name) => {
 const queue = [];
 queue.push(...graph[name]);
 const searched = []; // то что уже проверено
 while (queue.length > 0) {
   const [person, ...rest] = queue;
   queue.shift(person)
   if (!searched.includes(person)){
     if (personIsJon(person)) {
       console.log('I finally find ' + person);
       return true;
     } else {
       searched.push(person);
       queue.push(...graph[person]);
     }
   }
 }
 return false
}
searchName('you')
```

- Поиск в ширину позволяет определить, существует ли путь из А в Б
- Если существует, то поиск в ширину находит кратчайший путь
- Графы состоят из узлов и ребер, частный случай - деревья (без ребер идущих вверх)
- В направленном графе есть стрелки, в ненаправленном - нет (отношения идут в обе стороны);
- Очередь - FIFO, Стек - LIFO
- Список поиска лучше оформлять в виде очереди

## Алгоритм Дейкстры
- Поиск в ширину вычисляет кратчайший путь в невзвешенном графе
- Алгоритм Дейкстры вычисляет кратчайший путь во взвешенном графе, граф у которого есть веса у ребер
- Также он работает только с направленными ациклическими графами (DAG),
Алгоритм не может работать с ребрами, которые имеют отрицательный вес (есть алгоритм Беллмана-Форда)

### Алгоритм

1. Найти узел с наименьшей стоимостью
2. Обновить стоимости соседей этого узла
3. Повторять для всех узлов
4. Вычислить итоговый путь   

![](/images/img.png)      
[Код](https://repl.it/@NimfaMargo/Dijkstras-algorithm)
```
const graphStart = {
 'start': {'a': 6, 'b':2 }, // начальный узел
 'a': { 'fin': 1 },
 'b': { 'a': 3, 'fin': 5 },
 'fin': {}, // у конечного узла нет соседей
};

const costs = { // хеш для хранения стоимости всех узлов
 'a': 6,
 'b': 2,
 'fin': Infinity,
}

const parents = {
 'a': 'start',
 'b': 'start',
}

const processed = []; // обработанные узлы

const findLowestCostNode = (costs) => { // ф-ия для того чтобы найти наименьший узел
 let lowestCost = Infinity;
 let lowestCostNode = null;
 for (node in costs) { // перебрать все узлы
   const cost = costs[node];
   if (cost < Infinity && !processed.includes(node)) { // узел наим. и не обр.
     lowestCost = cost; // он назначается новым узлом с наим. стоимостью
     lowestCostNode = node
   }
 }
 return lowestCostNode;
}

const algorithm = () => {
 let node = findLowestCostNode(costs); // узел с наим. стоимостью
 while (node) {
   const cost = costs[node]; // стоимость узла
   const neighbors = graphStart[node]; // его соседи
   Object.keys(neighbors).map(el => { // перебор соседей
     const newCost = cost + neighbors[el]; // расстояние start -> B -> A
     if (costs[el] > newCost) { // сравнение стоимостей
       costs[el] = newCost; // обновление стоимости
       parents[el] = node; // назначаем узел новым родителем, тк ч/з него путь
     }
     return null
   });
   processed.push(node); // помечаем узел как обработанный
   node = findLowestCostNode(costs); // найти следующий узел
 }
 return parents;
}
algorithm(graphStart)
```
